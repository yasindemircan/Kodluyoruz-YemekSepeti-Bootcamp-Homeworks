# .net Homework-3[TutorialsTeacher](https://www.tutorialsteacher.com/online-test/csharp-test) üzerinde bulunan c# soruları çözülüp detaylı araştırılması## DelegateC# programlama dilinde tanımlanan ve metot olarak adlandırılan işlevlerin bellek adresini tutmak için kullanılan yapıya delegate veya temsilci denir.## EventEvent anahtar kelimesi ile tanımlanan bir değişkenin olay olduğunu açıkca belirtmek ve yönetmek için kullanılan anahtar kelimedir.## Value TypeCsharpta kullanmış olduğumuz value type değerler basit şekilde tanımladığımız değerlerdir. ```c#int a = 3  ```Vermiş olduğum örnekte a değeri herhangi bir yeri referans olarak göstermez, direkt olarak içerisinde 3 değerini barındırmaktadır.## Reference TypeDeğer içinde bellek üzerindeki bir adresin bilgisi taşınmaktadır. Örneğin bir nesne oluşturduğumuzda aslında biz referans tipi ile uğraşıyoruz. Örneğin bu durumu örneklersek;```c#Meyve elma = new Meyve(); ```Örneğin Meyve sınıfından bir instance alarak elma nesnesini oluşturduğumuzu farzedelim. İşte burada oluşturduğumuz elma nesnesi içinde aslında Meyve sınıfına ait referans değeri tutuyoruz. Referans type değişkenler oluşturulduğunda bunlar ilk başta içlerinde null değerleri taşırlar. Örneğin string değerler referans tipde değişkenlerdir.## StructAralarında mantıksal bir ilişki bulunan ama farklı türdeki verilerin bir arada bulunması gereken durumlarla karşılaşılabilir. İşte bu durumlarda belli bir grup verinin bir arada tutulması için oluşturulan yeni birime yapı (struct) denir.Yapılar(struct) değer türündedir. Dolayısıyla belleğin yığın (stack) bölümünde tutulurlar.Değer türleri belleğin yığın (stack) bölümünde tutulurken;referans türler belleğin öbek (heap) bölümünde tutulur. Örneğin sınıflar(class) referans türünde olduklarından dolayı belleğin öbek (heap) bölümünde tutulur.## IndexerDizilerde indeks numarasına göre çalışırken,SqlDataReader nesnesinde kolonları çekerken ya da bir koleksiyonda elemanlarımıza ulaşırken kullanırız.Mesela SqlDataReader’dan örnek vereyim.SqlDataReader dr adında bir nesnemiz olsun ve bu SqlDataReader’a çekilmiş verilerden istediğim kolona nasıl ulabilirim.dr[“kolonadi”] şeklinde.```c#class Indexer{    int[] sayilar = new int[5];    public int this[int index]    {        get        {            return sayilar[index];        }        set        {            sayilar[index] = value;        }    }} ```## PredicatePredicate özel bir Func delegesidir. Şöyle ki her zaman bool döndürür. Filtreleme veya select işlemlerinde yoğun olarak kullanılır. Örnegin, liste elimize geldi ama biz sadece karakter uzunluğu 5'ten fazla olanları istiyoruz.```c#Predicate<string> predicate = FindBigLength;IEnumerable<string> bigNameList = nameList.FindAll(predicate);foreach (var word in bigNameList)    Console.WriteLine(word);private bool FindBigLength(string name){   return name.Length > 5;} ```## Partial ClassPartial class bize bir class’ ı birden fazla class olarak bölmemize, constructor, değişken, property, metodları vs. düzenli bir şekilde ayrı ayrı oluşturmamızı sağlamaktadır. Fiziksel olarak birden fazla parça ile oluşan partial class’ lar, çalışma zamanında tek bir class olarak bütün elemanları içerisinde barındırmaktadır.Partial class ile fiziksel olarak parça class’ların birleşmesi için class isimlerinin aynı olması gerekmektedir. ## Dynamic Type Bazen derleme zamanında da değişken tipli tanımlamalara ihtiyaç olabilir. C# 4.0 bu esnekliği sağlamak için yeni bir tip eklemiştir: dynamic tipi. dynamic tipi tabiri caizse kılıktan kılığa girebilir, bukalemun gibi renk değiştirebilir, dynamic tipi bütün tiplere dönüştürülebilir.```c#static void Main() { dynamic i; dynamic s; i = 10; s = "Bu bir string'tir"; Console.WriteLine("i'nin tipi: " + i.GetType()); Console.WriteLine("i'nin değeri: " + i); //i'ye int tipiymiş gibi davranalım. i = i * 10; Console.WriteLine("i'nin yeni değeri: " + i); Console.WriteLine("str'nin tipi: " + s.GetType()); Console.WriteLine("str'nin değeri: " + s); //s'ye string tipiymiş gibi davranalım. s = s.ToUpper(); Console.WriteLine("s'nin yeni değeri: " + s); i = "i'nin tipi değişti";//Bu atamayla i'nin tipi otomatik olarak değişti Console.WriteLine("i'nin değeri: " + i); Console.WriteLine("i'nin yeni tipi: " + i.GetType()); } ```## ImmutableBurada immutable kavramını, nesne oluşturulduktan sonra, değeri değiştirilemeyen olarak tanımlayabiliriz.Immutable veri tiplerine örnek olarak, string, integer, double, byte gibi tipleri örnek verebiliriz.## Mutable Mutable da ise nesneleri oluşturduktan sonra, değerlerini değiştirebiliriz.Mutable veri tiplerine örnek olarak ise, Date, StringBuilder gibi tipleri örnek verebiliriz. Burada mutable olarak StringBuilder seçeneği sunulabilir ve string’e alternatif olarak düşünülebilir.## ActionAction ve Action<T> delege türleri .Net framework 3.5 ile gelen önceden tanımlanmış bir delege türüdür. Action<T> delege türleri Func<T> delegelerinin aksine hiçbir değer döndürmeyen metodları temsil etmektedir. Action delege türü hiçbir parametre almayan ve değer döndürmeyen metodları temsil eder. Adından da anlaşılacağı üzere bir fonksiyonu değil bir eylemi(action) temsil etmektedirler.## Func Func<T> önceden tanımlanmış olan ve T tipinde değerler döndüren metodları temsil eden bir delegedir. Func<T> tipi birden fazla parametre ile beslenebilecek şekilde hazırlanmış bir tiptir. Yani bir veya birden fazla parametre alabilecek metodları temsil eden önceden tanımlanmış bir delege türüdür. Func<T> kullandığımızda delege tanımlamamıza gerek kalmamaktadır.